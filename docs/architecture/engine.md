# Engine

**Engine** · `cmd/`

Третий шаг — запустить всё вместе. Toolkit и Realm готовы. Теперь вы описываете как приложение стартует, принимает запросы и останавливается.

---

## Что вы делаете на этом шаге

Вы реализуете **App** — обёртку над технологией взаимодействия: HTTP-сервер, consumer, scheduler, CLI. App не знает что делает бизнес. Он знает как принять запрос, передать управление в Realm и обработать результат.

---

## Apps

Каждый App оборачивает одну технологию. Получает delivery-сущности от Realm и регистрирует их. Обрабатывает результаты: `error` → 500, типизированный `ResponseError` → его код. Гарантирует работоспособность транспорта (panic recovery, логирование, retry).

Два типа: **long-running** (HTTP, consumer, scheduler) и **short-running** (CLI, скрипты, миграции).

→ [Apps — как писать и структурировать](/architecture/apps)

## Main

Дирижёр. Собирает конфиги всех слоёв, инициализирует в строгом порядке: `infra → services → apps`. Запускает, ожидает сигнала ОС, останавливает в обратном порядке.

→ [Main](/architecture/main)

---

## Итог

Все три слоя готовы — проект собран. Вот как они взаимодействуют при входящем запросе:

```
Запрос
  ↓
App (Engine)           принимает запрос, передаёт в Delivery
  ↓
Delivery (Realm)       выполняет бизнес-логику, вызывает Services
  ↓
Services (Toolkit)     работает с технологией — БД, очередь, API
  ↓
Ответ
  ↑
App                    получает результат, переводит на язык протокола
```

Каждый слой знает только своё:

| Слой | Знает | Не знает |
|------|-------|----------|
| **Toolkit** | как работать с технологией | что делает бизнес |
| **Realm** | что делать при запросе | как работает транспорт |
| **Engine** | когда передать управление | что делает бизнес |

→ [Конфигурация](/architecture/configs) — как настраивается вся система
